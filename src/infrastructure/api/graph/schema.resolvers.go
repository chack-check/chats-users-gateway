package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"

	"github.com/chack-check/chats-users-gateway/domain/messages"
	"github.com/chack-check/chats-users-gateway/infrastructure/api/graph/model"
	"github.com/chack-check/chats-users-gateway/infrastructure/api/middlewares"
	"github.com/chack-check/chats-users-gateway/infrastructure/api/utils"
	"github.com/chack-check/chats-users-gateway/infrastructure/protochats"
	"github.com/chack-check/chats-users-gateway/infrastructure/protousers"
	jwt "github.com/golang-jwt/jwt/v5"
)

// GetChatMessages is the resolver for the getChatMessages field.
func (r *queryResolver) GetChatMessages(ctx context.Context, chatID int, offset *int, limit *int) (model.PaginatedMessagesWithUsersErrorResponse, error) {
	token, _ := ctx.Value("token").(*jwt.Token)
	if err := utils.UserRequired(token); err != nil {
		return model.ErrorResponse{Message: "Token required"}, nil
	}

	tokenSubject, err := middlewares.GetTokenSubject(token)
	if err != nil {
		return model.ErrorResponse{Message: "Incorrect token"}, nil
	}

	var offsetValue int
	if offset == nil || *offset < 0 {
		offsetValue = 0
	} else {
		offsetValue = *offset
	}

	var limitValue int
	if limit == nil || *limit < 0 {
		limitValue = 0
	} else {
		limitValue = *limit
	}

	chatsClient := protochats.ChatsClientConnect()
	usersClient := protousers.UsersClientConnect()
	handler := messages.NewGetChatMessagesHandler(
		&protochats.MessagesAdapter{Client: chatsClient, Token: token.Raw},
		&protochats.ChatsAdapter{Client: chatsClient, Token: token.Raw},
		&protousers.UsersAdapter{Client: usersClient},
	)
	messages := handler.Execute(chatID, tokenSubject.UserId, offsetValue, limitValue)
	messagesResponse := DomainPaginatedMessagesWithUsersToResponse(messages)
	return &messagesResponse, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
